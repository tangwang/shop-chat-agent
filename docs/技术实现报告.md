# Shop Chat Agent 技术实现报告

## 1. 项目定位与总体目标

本项目是一个 **Shopify 店铺 AI 导购智能体**模板，核心目标是让消费者在店铺前台通过聊天完成以下操作：

- 询问商品与推荐；
- 查询政策 / FAQ；
- 购物车增删改与发起结账；
- 订单与售后相关查询（需用户授权）。

实现上采用「**前端聊天组件 + 后端 Agent 编排服务 + MCP 工具调用 + 数据持久化**」的架构。

---

## 2. 技术栈与运行时组成

### 2.1 后端

- 框架：React Router（服务端路由）
- LLM：Anthropic Claude（流式接口）
- 工具协议：MCP（Model Context Protocol）JSON-RPC
- 鉴权生态：Shopify App（Admin + Customer Account OAuth）
- 数据层：Prisma + SQLite

### 2.2 前端

- Shopify Theme Extension（`chat-interface.liquid` + `chat.js` + `chat.css`）
- 浏览器端通过 `fetch + SSE` 消费流式响应

### 2.3 与 Shopify 的连接

- 嵌入式 App 侧：`@shopify/shopify-app-react-router`
- 店铺前台 Chat 侧：Theme block 注入脚本并透传 `shop.id`、提示词类型等配置

---

## 3. 目录级组件拆解

> 以下只列与智能体实现直接相关的核心模块。

- `app/routes/chat.jsx`：聊天 API 主入口，处理 POST/GET、历史记录、SSE。
- `app/services/claude.server.js`：Claude 封装（系统提示词选择、流式回调、tool_use 提取）。
- `app/mcp-client.js`：MCP 客户端（连接 storefront/customer 两类 MCP 端点、调用工具）。
- `app/services/tool.server.js`：工具调用结果归一化处理（错误、商品结果提取、tool_result 回写上下文）。
- `app/services/streaming.server.js`：SSE 封装（统一消息发送、错误映射、流关闭）。
- `app/auth.server.js` + `app/routes/auth.callback.jsx` + `app/routes/auth.token-status.jsx`：Customer Account OAuth + PKCE。
- `app/db.server.js` + `prisma/schema.prisma`：会话、消息、token、PKCE verifier 与 customer account URL 持久化。
- `app/prompts/prompts.json`：系统提示词池（`standardAssistant` / `enthusiasticAssistant`）。
- `extensions/chat-bubble/assets/chat.js`：前端消息渲染、SSE 事件处理、认证弹窗与轮询。
- `extensions/chat-bubble/blocks/chat-interface.liquid`：前端注入配置（promptType、welcome message、shopId）。

---

## 4. Agent 主流程（端到端时序）

## 4.1 初始化与请求入口

1. 用户在店铺前台输入消息。
2. `chat.js` 读取 `sessionStorage.shopAiConversationId`，组装：
   - `message`
   - `conversation_id`
   - `prompt_type`
3. 前端 `POST https://localhost:3458/chat`，`Accept: text/event-stream`。

## 4.2 后端会话编排（`/chat`）

`chat.jsx` 在 `handleChatRequest` 中：

- 校验 `message` 必填；
- 若无 `conversation_id`，用时间戳生成；
- 创建 SSE stream；
- 调用 `handleChatSession` 执行完整 Agent 回合。

## 4.3 会话上下文构建

`handleChatSession` 关键步骤：

1. 初始化 `ClaudeService` 与 `ToolService`；
2. 从请求头提取：
   - `X-Shopify-Shop-Id`
   - `Origin`（作为 shopDomain）
3. 通过 `getCustomerAccountUrls` 获取 customer MCP 所需 URL（优先 DB，其次 `.well-known` 拉取）；
4. 初始化 `MCPClient`，连接 storefront/customer 工具端点并汇总工具列表；
5. 将用户消息保存到 DB，再从 DB 读取完整历史，转换成 Claude 所需 `messages` 结构。

## 4.4 LLM 推理与工具循环

后端采用 **while 循环**执行多轮工具链：

- 条件：`finalMessage.stop_reason !== "end_turn"`；
- 每轮调用 `claudeService.streamConversation`；
- Claude 文本增量通过 SSE `chunk` 推送前端；
- Claude 返回 `tool_use` 时：
  1. SSE 下发 `tool_use`（可视化“正在调用工具”）；
  2. `mcpClient.callTool(toolName, toolArgs)`；
  3. 结果进入 `ToolService`：
     - 成功：必要时提取商品卡片；
     - 失败：写入错误或触发 `auth_required`。
  4. 将 tool_result 以 `role: user` 的结构写回对话历史；
  5. SSE 下发 `new_message`，通知前端创建下一条 assistant 气泡继续流式输出。

循环结束后发送 `end_turn`；若有商品结果，额外发送 `product_results`。

---

## 5. 各模块输入输出（I/O 合约）

## 5.1 `/chat` 路由 I/O

### 输入

- `POST /chat`
  - Body(JSON):
    - `message: string`（必填）
    - `conversation_id?: string`
    - `prompt_type?: string`
  - Header:
    - `Accept: text/event-stream`
    - `X-Shopify-Shop-Id: string`
    - `Origin: https://{shop-domain}`

- `GET /chat?history=true&conversation_id=...`
  - 返回历史消息 JSON

### 输出（SSE 事件）

- `id`：下发会话 ID
- `chunk`：文本增量
- `message_complete`：单条 assistant 完整消息结束
- `tool_use`：工具调用可视化文本
- `new_message`：提示前端开启下一条 assistant 气泡
- `content_block_complete`：内容块完成（前端用于打字指示）
- `auth_required`：需要用户授权
- `product_results`：商品卡片数组
- `end_turn`：本回合结束
- `error` / `rate_limit_exceeded`：错误类事件

## 5.2 Claude Service I/O

### 输入

- `messages`：完整历史
- `promptType`：系统提示词类型
- `tools`：可调用工具列表

### 输出

- 流式回调：`onText` / `onMessage` / `onContentBlock`
- 最终消息：`finalMessage`
- 若存在 `tool_use`，由 `onToolUse` 回调逐个处理

## 5.3 MCP Client I/O

### 输入

- 构造参数：`hostUrl`, `conversationId`, `shopId`, `customerMcpEndpoint?`
- `callTool(name, arguments)`

### 输出

- `connectToStorefrontServer/connectToCustomerServer`：标准化后的工具描述数组
- `callTool`：
  - 正常返回 MCP result
  - `401` 时返回 `{ error: { type: "auth_required", data: markdownLink } }`
  - 其他异常返回 `internal_error`

## 5.4 Tool Service I/O

### 输入

- `toolUseResponse`、`toolName`、`toolUseId`
- 当前 `conversationHistory`

### 输出

- 统一把 tool_result 追加到历史（并持久化）
- `search_shop_catalog` 时提取最多 3 个商品，供 `product_results` 事件输出

## 5.5 前端 `chat.js` I/O

### 输入

- 用户文本输入
- 服务端 SSE 事件流
- `window.shopChatConfig`（promptType, welcomeMessage）
- `window.shopId`

### 输出

- DOM 更新（消息、工具调用折叠块、商品卡片）
- `sessionStorage` 状态：
  - `shopAiConversationId`
  - `shopAiLastMessage`
  - `shopAiTokenPollingId`
- 认证弹窗与 token 轮询

---

## 6. 提示词系统（Prompt Engineering）

提示词文件：`app/prompts/prompts.json`。

当前内置两套 system prompt：

1. `standardAssistant`
2. `enthusiasticAssistant`（人设 Zara，语气更活泼）

两者都强调了输出格式要求：

- 购物车/结账链接必须 markdown 化；
- 列表与步骤使用规范 Markdown；
- 关键点适度加粗。

提示词选择链路：

1. Theme block 选择 `system_prompt`；
2. 通过 `window.shopChatConfig.promptType` 注入前端；
3. 前端请求体带 `prompt_type`；
4. 后端 `ClaudeService.getSystemPrompt(promptType)` 取对应系统提示词；
5. 若类型无效，回退到 `AppConfig.api.defaultPromptType`。

---

## 7. 认证与授权链路（Customer MCP）

## 7.1 触发条件

当 customer 侧工具调用返回 `401`：

- `MCPClient.callCustomerTool` 调用 `generateAuthUrl`；
- 返回 `auth_required` 错误，其 `data` 内包含 markdown 授权链接。

## 7.2 PKCE/OAuth 关键步骤

1. `generateAuthUrl` 生成 `state = conversationId-shopId`；
2. 生成 `code_verifier` 与 `code_challenge`；
3. `storeCodeVerifier(state, verifier)` 持久化（10 分钟有效）；
4. 拼接授权 URL 返回前端。

## 7.3 前端恢复会话

1. 前端捕获 `auth_required` 事件，保存最后一句用户问题；
2. 用户点击授权链接，弹窗打开；
3. 回调路由 `/auth/callback` 用 `code + verifier` 换 token，并 `storeCustomerToken`；
4. 前端轮询 `/auth/token-status`，状态变为 `authorized` 后自动重新发送上一次问题。

---

## 8. 数据模型与持久化设计

Prisma 模型要点：

- `Session`：Shopify app 会话。
- `Conversation` + `Message`：聊天记录主表与明细表（按时间升序拉取）。
- `CustomerToken`：按 `conversationId` 存 customer access token 及过期时间。
- `CodeVerifier`：PKCE verifier（按 state 唯一）。
- `CustomerAccountUrls`：缓存 mcpApi/auth/token URL，避免反复查询 `.well-known`。

消息存储策略：

- 用户原始消息：`role=user`，`content=plain text`；
- assistant 消息：`content=JSON.stringify(message.content)`；
- tool_result：同样以 JSON 形式写入 user role，用于后续 LLM 上下文连续性。

---

## 9. 流式协议与前端渲染机制

SSE 封装由 `createSseStream`/`createStreamManager` 统一完成：

- 所有消息标准格式：`data: {json}\n\n`；
- 统一错误映射：鉴权失败、限流、通用错误；
- `finally` 中确保流关闭，防止悬挂连接。

前端渲染要点：

- `chunk` 持续拼接到当前 assistant 气泡；
- `message_complete` 后进行 markdown 格式化；
- `new_message` 时创建新的 assistant 气泡，支持“工具调用后续写”；
- `product_results` 渲染商品卡片（含图片、价格、Add to Cart 快捷按钮）。

---

## 10. 配置项与环境变量

### 10.1 代码内配置（`AppConfig`）

- 默认模型：`claude-sonnet-4-20250514`
- `maxTokens=2000`
- 默认 prompt 类型：`standardAssistant`
- 商品结果展示上限：3

### 10.2 关键环境变量

- `CLAUDE_API_KEY`
- `SHOPIFY_API_KEY`
- `SHOPIFY_API_SECRET`
- `SHOPIFY_APP_URL`
- `SCOPES`
- `REDIRECT_URL`（Customer OAuth 回调）

---

## 11. 异常处理策略

- `/chat` 入参缺失：400 + 错误 JSON。
- SSE 过程异常：`streaming.server.js` 统一转为事件。
- MCP 连接失败：记录 warning，允许“无工具”继续大模型对话。
- Tool 调用异常：写入 tool_result 反馈给模型，而不是直接中断会话。
- token 持久化失败：日志记录，但不阻塞用户完成 OAuth 回调页面。

---

## 12. 项目当前实现特点与改进建议

## 12.1 现有优势

- 架构清晰：前端展示、后端编排、工具调用、鉴权、存储职责分离。
- 工具回写策略正确：tool_result 进入上下文，支持多步工具链。
- 前端体验完整：打字机效果、工具调用可视化、鉴权后自动续聊。

## 12.2 可优化点

1. **流式路径硬编码**：`chat.js` 中请求地址写死为 `https://localhost:3458`，建议改成可配置环境地址。
2. **会话 ID 生成策略**：当前使用时间戳，建议改为更稳定/不可预测 ID（如 UUID）。
3. **消息存储规范化**：`Message.content` 混存纯文本与 JSON 字符串，可增加 `contentType` 字段提升可维护性。
4. **安全与审计**：建议补充 tool 调用日志结构化埋点（toolName、latency、status）。
5. **测试覆盖**：目前模板偏示例化，建议新增：
   - `/chat` SSE 合约测试；
   - auth callback/token-status 集成测试；
   - tool_result 历史回写单元测试。

---

## 13. 总结

该项目实现的是一个面向 Shopify 店铺的「**可工具调用、可流式输出、可用户授权扩展**」的智能体系统：

- 使用 Claude 做自然语言理解与行动规划；
- 使用 MCP 统一承载店铺与客户域工具；
- 使用 SSE 提供低延迟交互体验；
- 使用 Prisma 持久化对话与授权状态，支持上下文连续与会话恢复。

如果你后续要做企业级落地，建议优先投入在：

1. 可观测性（Tracing + Metrics + Structured Log）；
2. 提示词与工具策略版本化；
3. 安全策略（鉴权、速率限制、敏感操作二次确认）；
4. 自动化测试与回归流程。
